<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Exam Tracker</title>
  <style>
    html, body { margin:0; padding:0; height:100vh; overflow:hidden; }
    #container { position:relative; width:100%; height:100%; background:#fafafa; }
    .circle {
      position:absolute;
      border-radius:50%;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      font-family:sans-serif;
      text-align:center;
      cursor:pointer;
      user-select:none;
      box-sizing:content-box;
    }
    .circle, .circle * { user-select:none; -webkit-user-select:none; -ms-user-select:none; }
    .circle:active { cursor:grabbing; }
    #cue {
      position:absolute;
      height:4px;
      background:#000;
      transform-origin:left center;
      display:none;
      pointer-events:none;
    }
    #cue::after {
      content:"";
      position:absolute;
      right:0;
      top:50%;
      transform:translateY(-50%);
      width:0;
      height:0;
      border-left:8px solid #000;
      border-top:6px solid transparent;
      border-bottom:6px solid transparent;
    }
  </style>
</head>
<body>
  <div id="container"></div>
  <script>
    // exam definitions
    const exams = [
      {subject:'ss',date:'2025-07-03',description:'Stage 2'},
      {subject:'history',date:'2025-07-10',description:'CT'},
      {subject:'hcl',date:'2025-07-17',description:'O-level Oral'},
      {subject:'ss',date:'2025-07-17',description:'Stage 3'},
      {subject:'hcl',date:'2025-07-24',description:'CT'},
      {subject:'a math',date:'2025-08-07',description:'CT'},
      {subject:'PW',date:'2025-08-07',description:'Written Report'},
      {subject:'PW',date:'2025-08-14',description:'Final Evaluation'},
      {subject:'physics',date:'2025-08-28',description:'Practical Exam'},
      {subject:'chem',date:'2025-09-04',description:'Practical Exam'}
    ];

    const container = document.getElementById('container');
    const cue = document.createElement('div'); cue.id = 'cue'; container.appendChild(cue);

    let W = container.clientWidth, H = container.clientHeight;
    window.addEventListener('resize', ()=>{ W = container.clientWidth; H = container.clientHeight; });

    // convert HSL to RGB for luminance
    function hslToRgb(h, s, l) {
      s/=100; l/=100;
      const c = (1 - Math.abs(2*l - 1)) * s;
      const x = c * (1 - Math.abs((h/60)%2 - 1));
      const m = l - c/2;
      let r1=0, g1=0, b1=0;
      if(h<60){r1=c;g1=x;} else if(h<120){r1=x;g1=c;} else if(h<180){g1=c; b1=x;}
      else if(h<240){g1=x; b1=c;} else if(h<300){r1=x; b1=c;} else {r1=c; b1=x;}
      return { r:Math.round((r1+m)*255), g:Math.round((g1+m)*255), b:Math.round((b1+m)*255) };
    }

    // pastel rainbow subject colors
    const pastelHues = [0,30,60,120,180,240,300];
    const pastelMap = {};
    let pastelIndex = 0;
    function subjectColor(sub) {
      if(pastelMap[sub]) return pastelMap[sub];
      let color;
      if(pastelIndex < pastelHues.length) {
        color = { h: pastelHues[pastelIndex], s:60, l:85 };
        pastelIndex++;
      } else {
        let hash=0; for(let c of sub) hash=(hash*31+c.charCodeAt(0))%360;
        color = { h:hash, s:70, l:50 };
      }
      pastelMap[sub] = color;
      return color;
    }

    const FRICTION = 0.98;
    const circles = [];
    let aimBall = null;

    (function init(){
      const now = Date.now();
      const future = exams.map(e=>{ const d=Math.ceil((new Date(e.date)-now)/(1000*60*60*24)); e.days=d; return d>=0?e:null; }).filter(e=>e);
      if(!future.length) return;

      const days = future.map(e=>e.days);
      const minDays = Math.min(...days), maxDays = Math.max(...days);
      const span = maxDays - minDays;

      const maxR = Math.min(W, H) / 8;
      const minR = maxR/2;

      future.forEach(e => {
        const f = span>0 ? (maxDays - e.days)/span : 1;
        const innerR = minR + (maxR - minR) * f;
        const pad = innerR*0.1;
        const r = innerR + pad;

        const div = document.createElement('div');
        div.className = 'circle';
        div.style.width = div.style.height = (2*r)+'px';
        div.style.padding = pad+'px';
        div.style.fontSize = (innerR/4)+'px';

        const hsl = subjectColor(e.subject);
        div.style.background = `hsl(${hsl.h},${hsl.s}%,${hsl.l}%)`;
        const {r:rr,g:gg,b:bb} = hslToRgb(hsl.h,hsl.s,hsl.l);
        div.style.color = ((0.2126*rr + 0.7152*gg + 0.0722*bb)/255 < 0.5) ? '#fff' : '#000';

        div.innerHTML = `<div>${e.subject}</div><div>${e.date}</div><div>${e.description}</div><div>${e.days}d</div>`;
        container.appendChild(div);
        circles.push({ el:div, days:e.days, vx:0, vy:0, r });
      });

      // place nearest exam in center
      circles.sort((a,b)=>a.days - b.days);
      const center = circles[0];
      center.x = W/2; center.y = H/2;

      // ring others around
      const others = circles.slice(1);
      const outerMax = Math.max(...others.map(c=>c.r));
      const ringR = center.r + outerMax + 20;
      others.forEach((c,i)=>{
        const ang = 2*Math.PI * i/others.length;
        c.x = W/2 + ringR * Math.cos(ang);
        c.y = H/2 + ringR * Math.sin(ang);
      });

      // cue events
      container.addEventListener('mousedown', ev => {
        const mx = ev.clientX - container.offsetLeft;
        const my = ev.clientY - container.offsetTop;
        circles.forEach(c => {
          const rad = c.el.offsetWidth/2;
          if(Math.hypot(mx-c.x,my-c.y) < rad) aimBall = c;
        });
      });
      container.addEventListener('mousemove', ev => {
        if(!aimBall) return;
        const mx = ev.clientX - container.offsetLeft;
        const my = ev.clientY - container.offsetTop;
        const dx = mx - aimBall.x;
        const dy = my - aimBall.y;
        const dist = Math.hypot(dx,dy);
        const ang = Math.atan2(dy,dx);
        cue.style.display = 'block';
        cue.style.width = dist+'px';
        cue.style.transform = `translate(${aimBall.x}px,${aimBall.y}px) rotate(${ang}rad)`;
      });
      container.addEventListener('mouseup', ev => {
        if(!aimBall) return;
        const mx = ev.clientX - container.offsetLeft;
        const my = ev.clientY - container.offsetTop;
        const dx = mx - aimBall.x;
        const dy = my - aimBall.y;
        aimBall.vx = -dx * 0.2;
        aimBall.vy = -dy * 0.2;
        cue.style.display = 'none';
        aimBall = null;
      });

      requestAnimationFrame(loop);
    })();

    function loop(){
      circles.forEach(c=>{
        if(c!==aimBall){ c.vx *= FRICTION; c.vy *= FRICTION; c.x += c.vx; c.y += c.vy; }
        // wall bounce
        const rad = c.el.offsetWidth/2;
        if(c.x-rad < 0){ c.x = rad; c.vx *= -1; }
        if(c.x+rad > W){ c.x = W - rad; c.vx *= -1; }
        if(c.y-rad < 0){ c.y = rad; c.vy *= -1; }
        if(c.y+rad > H){ c.y = H - rad; c.vy *= -1; }
      });
      // collisions
      for(let i=0;i<circles.length;i++){
        for(let j=i+1;j<circles.length;j++){
          const A = circles[i], B = circles[j]; if(A===aimBall||B===aimBall) continue;
          const radA = A.el.offsetWidth/2, radB = B.el.offsetWidth/2;
          const dx = B.x - A.x;
          const dy = B.y - A.y;
          const dist = Math.hypot(dx,dy);
          const minDist = radA + radB;
          if(dist < minDist){
            const overlap = (minDist - dist)/2;
            const nx = dx/dist;
            const ny = dy/dist;
            A.x -= nx * overlap;
            A.y -= ny * overlap;
            B.x += nx * overlap;
            B.y += ny * overlap;
            const pa = A.vx*nx + A.vy*ny;
            const pb = B.vx*nx + B.vy*ny;
            A.vx += (pb - pa)*nx;
            A.vy += (pb - pa)*ny;
            B.vx += (pa - pb)*nx;
            B.vy += (pa - pb)*ny;
          }
        }
      }
      circles.forEach(c=>{
        const rad = c.el.offsetWidth/2;
        c.el.style.transform = `translate(${c.x - rad}px,${c.y - rad}px)`;
      });
      requestAnimationFrame(loop);
    }
  </script>
</body>
</html>
